"""
Задача 3. Кэширование для ускорения вычислений
Контекст
Вы разрабатываете программу для оптимизации вычислений чисел Фибоначчи. Числа Фибоначчи
вычисляются рекурсивной функцией, каждое число равно сумме двух предыдущих чисел. Однако вы
заметили, что при больших значениях чисел Фибоначчи вычисления занимают значительное время,
так как многие значения вычисляются повторно. Вам поручено создать декоратор, который кэширует
результаты вызова функции и позволяет избежать повторных вычислений для одних и тех же аргументов.

Задача
Создайте декоратор, который кэширует (сохраняет для дальнейшего использования) результаты вызова
функции и, при повторном вызове с теми же аргументами, возвращает сохранённый результат.

Примените его к рекурсивной функции вычисления чисел Фибоначчи.
В итоге декоратор должен проверять аргументы, с которыми вызывается функция, и, если такие
аргументы уже использовались, должен вернуть сохранённый результат вместо запуска расчёта.

Советы
- Для хранения результатов удобно использовать словарь, так как поиск элементов внутри словаря
будет иметь сложность, равную в среднем O(1).
- При этом не стоит хранить все вычисления в одном словаре, созданном снаружи функций
(в глобальной области видимости). Лучше создавать
отдельные словари для каждой декорируемой функции.
"""

def cache_decorator(func):
    cache = {}

    def wrapper(n):
        if n in cache:
            return cache[n]
        result = func(n)
        cache[n] = result
        return result

    return wrapper


@cache_decorator
def fibonacci(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)


if __name__ == "__main__":
    print(fibonacci(10))
    print(fibonacci(20))
    print(fibonacci(30))
    print(fibonacci(10))
